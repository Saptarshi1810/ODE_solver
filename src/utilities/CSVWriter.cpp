/**
 * @file CSVWriter.cpp
 * @brief Implementation of CSV file writing for ODE solver results
 * @author Your Name
 * @version 1.0.0
 *
 * This module provides efficient CSV file writing for saving ODE solutions,
 * root finding results, and other numerical data. Features include:
 * - Configurable delimiters (comma, tab, semicolon, etc.)
 * - Precision control for floating-point output
 * - Scientific notation support
 * - Comment lines for metadata
 * - ODE solution export with automatic formatting
 * - Buffered I/O for performance
 */

#include "ode_solver/Utilities.hpp"
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <algorithm>

namespace ode_solver::utils {

/**
 * @brief Constructor - Opens CSV file for writing
 *
 * @param filename Path to output CSV file
 * @param config Configuration for CSV format
 * @throws std::runtime_error if file cannot be opened
 */
CSVWriter::CSVWriter(const std::string& filename, const Config& config)
    : config_(config), header_written_(false) {
    
    file_.open(filename, std::ios::out | std::ios::trunc);
    
    if (!file_.is_open()) {
        throw std::runtime_error("CSVWriter: Cannot open file '" + filename + "'");
    }
    
    // Set floating-point precision
    file_ << std::fixed << std::setprecision(config_.precision);
}

/**
 * @brief Destructor - Flushes and closes the file
 */
CSVWriter::~CSVWriter() {
    if (file_.is_open()) {
        file_.flush();
        file_.close();
    }
}

/**
 * @brief Write header row with column names
 *
 * @param headers Vector of column header strings
 */
void CSVWriter::writeHeader(const std::vector<std::string>& headers) {
    validateOpen();
    
    if (headers.empty()) {
        throw std::runtime_error("CSVWriter: Cannot write empty header");
    }
    
    for (size_t i = 0; i < headers.size(); ++i) {
        file_ << headers[i];
        if (i < headers.size() - 1) {
            file_ << config_.delimiter;
        }
    }
    file_ << "\n";
    file_.flush();
    
    header_written_ = true;
}

/**
 * @brief Write a single row of data
 *
 * @param row Vector of doubles to write
 */
void CSVWriter::writeRow(const std::vector<double>& row) {
    validateOpen();
    
    if (row.empty()) {
        throw std::runtime_error("CSVWriter: Cannot write empty row");
    }
    
    for (size_t i = 0; i < row.size(); ++i) {
        file_ << formatValue(row[i]);
        if (i < row.size() - 1) {
            file_ << config_.delimiter;
        }
    }
    file_ << "\n";
}

/**
 * @brief Write multiple rows of data
 *
 * @param rows Vector of rows (each row is a vector of doubles)
 */
void CSVWriter::writeRows(const std::vector<std::vector<double>>& rows) {
    validateOpen();
    
    if (rows.empty()) {
        return;
    }
    
    for (const auto& row : rows) {
        if (!row.empty()) {
            for (size_t i = 0; i < row.size(); ++i) {
                file_ << formatValue(row[i]);
                if (i < row.size() - 1) {
                    file_ << config_.delimiter;
                }
            }
            file_ << "\n";
        }
    }
    file_.flush();
}

/**
 * @brief Write a comment line
 *
 * @param comment Comment text (without the comment character)
 */
void CSVWriter::writeComment(const std::string& comment) {
    validateOpen();
    
    file_ << config_.comment_char << " " << comment << "\n";
    file_.flush();
}

/**
 * @brief Write an ODE solution to CSV with automatic formatting
 *
 * @param solution ODESolution object containing time and solution data
 * @param variable_names Names for each component (auto-generated if empty)
 * @param include_metadata Include header comments with metadata
 */
void CSVWriter::writeSolution(const ODESolution& solution,
                             const std::vector<std::string>& variable_names,
                             bool include_metadata) {
    validateOpen();
    
    // Write metadata comments if requested
    if (include_metadata) {
        writeComment("ODE Solution");
        writeComment("Generated by ODE Solver");
        writeComment("Columns: time, y1, y2, ...");
    }
    
    // Prepare headers
    std::vector<std::string> headers;
    headers.push_back("time");
    
    if (!variable_names.empty()) {
        for (const auto& name : variable_names) {
            headers.push_back(name);
        }
    } else {
        // Auto-generate variable names
        for (size_t i = 0; i < solution.y[0].size(); ++i) {
            headers.push_back("y" + std::to_string(i + 1));
        }
    }
    
    // Write header
    if (config_.write_header) {
        writeHeader(headers);
    }
    
    // Write data
    for (size_t i = 0; i < solution.t.size(); ++i) {
        std::vector<double> row;
        row.push_back(solution.t[i]);
        
        for (size_t j = 0; j < solution.y[i].size(); ++j) {
            row.push_back(solution.y[i][j]);
        }
        
        writeRow(row);
    }
}

/**
 * @brief Flush output buffer to disk
 */
void CSVWriter::flush() {
    validateOpen();
    file_.flush();
}

/**
 * @brief Check if file is open
 */
bool CSVWriter::isOpen() const {
    return file_.is_open();
}

/**
 * @brief Format a double value according to configuration
 *
 * @param value The value to format
 * @return Formatted string representation
 */
std::string CSVWriter::formatValue(double value) const {
    // Handle special values
    if (std::isnan(value)) {
        return "NaN";
    }
    if (std::isinf(value)) {
        return (value > 0) ? "Inf" : "-Inf";
    }
    
    std::ostringstream oss;
    
    if (config_.scientific) {
        oss << std::scientific << std::setprecision(config_.precision) << value;
    } else {
        oss << std::fixed << std::setprecision(config_.precision) << value;
    }
    
    return oss.str();
}

/**
 * @brief Validate that file is open
 *
 * @throws std::runtime_error if file is not open
 */
void CSVWriter::validateOpen() const {
    if (!file_.is_open()) {
        throw std::runtime_error("CSVWriter: File is not open");
    }
}

// ============================================================================
// CSVReader Implementation
// ============================================================================

/**
 * @brief Constructor - Opens CSV file for reading
 *
 * @param filename Path to input CSV file
 * @param config Configuration for CSV format
 * @throws std::runtime_error if file cannot be opened
 */
CSVReader::CSVReader(const std::string& filename, const Config& config)
    : filename_(filename), config_(config) {
    
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("CSVReader: Cannot open file '" + filename + "'");
    }
    
    // Read first line to detect delimiter and extract headers if present
    std::string first_line;
    if (std::getline(file, first_line)) {
        // Auto-detect delimiter if requested (config_.delimiter == 0)
        if (config_.delimiter == 0) {
            config_.delimiter = detectDelimiter(first_line);
        }
        
        // Extract headers if present
        if (config_.has_header) {
            headers_ = parseLine(first_line);
        }
    }
}

/**
 * @brief Read all data from CSV file
 *
 * @return Vector of rows, each row is a vector of doubles
 */
std::vector<std::vector<double>> CSVReader::readAll() {
    std::ifstream file(filename_);
    if (!file.is_open()) {
        throw std::runtime_error("CSVReader: Cannot open file '" + filename_ + "'");
    }
    
    std::vector<std::vector<double>> data;
    std::string line;
    bool skip_first = config_.has_header;
    
    while (std::getline(file, line)) {
        // Skip header line if present
        if (skip_first) {
            skip_first = false;
            continue;
        }
        
        // Skip empty lines if requested
        if (config_.skip_empty_lines && line.empty()) {
            continue;
        }
        
        // Skip comment lines
        if (!config_.comment_char.empty() &&
            line.find(config_.comment_char) == 0) {
            continue;
        }
        
        // Parse line
        auto string_values = parseLine(line);
        std::vector<double> numeric_values;
        
        for (const auto& str_val : string_values) {
            try {
                numeric_values.push_back(parseValue(str_val));
            } catch (...) {
                // Skip lines with non-numeric data
                break;
            }
        }
        
        if (!numeric_values.empty() &&
            numeric_values.size() == string_values.size()) {
            data.push_back(numeric_values);
        }
    }
    
    return data;
}

/**
 * @brief Read specific columns by index
 *
 * @param column_indices Vector of column indices to read
 * @return Vector of rows with only specified columns
 */
std::vector<std::vector<double>> CSVReader::readColumns(
    const std::vector<size_t>& column_indices) {
    
    auto all_data = readAll();
    
    if (all_data.empty()) {
        return {};
    }
    
    // Validate column indices
    for (size_t idx : column_indices) {
        if (idx >= all_data[0].size()) {
            throw std::runtime_error(
                "CSVReader: Column index " + std::to_string(idx) + " out of range");
        }
    }
    
    // Extract specified columns
    std::vector<std::vector<double>> result;
    for (const auto& row : all_data) {
        std::vector<double> selected_row;
        for (size_t idx : column_indices) {
            selected_row.push_back(row[idx]);
        }
        result.push_back(selected_row);
    }
    
    return result;
}

/**
 * @brief Read specific columns by name
 *
 * @param column_names Vector of column names to read
 * @return Vector of rows with only specified columns
 */
std::vector<std::vector<double>> CSVReader::readColumns(
    const std::vector<std::string>& column_names) {
    
    // Map column names to indices
    std::vector<size_t> indices;
    
    for (const auto& name : column_names) {
        auto it = std::find(headers_.begin(), headers_.end(), name);
        if (it == headers_.end()) {
            throw std::runtime_error(
                "CSVReader: Column '" + name + "' not found in header");
        }
        indices.push_back(std::distance(headers_.begin(), it));
    }
    
    return readColumns(indices);
}

/**
 * @brief Get number of rows in CSV file
 */
size_t CSVReader::getRowCount() const {
    std::ifstream file(filename_);
    size_t count = 0;
    std::string line;
    
    while (std::getline(file, line)) {
        if (config_.skip_empty_lines && line.empty()) {
            continue;
        }
        if (!config_.comment_char.empty() &&
            line.find(config_.comment_char) == 0) {
            continue;
        }
        if (config_.has_header && count == 0) {
            count++;
            continue;
        }
        count++;
    }
    
    return count;
}

/**
 * @brief Get number of columns in CSV file
 */
size_t CSVReader::getColumnCount() const {
    return headers_.size();
}

/**
 * @brief Auto-detect delimiter from first line
 *
 * @param line First line of CSV file
 * @return Detected delimiter character
 */
char CSVReader::detectDelimiter(const std::string& line) {
    // Count occurrences of common delimiters
    int comma_count = 0, semicolon_count = 0, tab_count = 0, pipe_count = 0;
    
    for (char c : line) {
        if (c == ',') comma_count++;
        else if (c == ';') semicolon_count++;
        else if (c == '\t') tab_count++;
        else if (c == '|') pipe_count++;
    }
    
    // Return most common delimiter
    if (comma_count > 0) return ',';
    if (semicolon_count > 0) return ';';
    if (tab_count > 0) return '\t';
    if (pipe_count > 0) return '|';
    
    // Default to comma
    return ',';
}

/**
 * @brief Parse a CSV line into individual fields
 *
 * @param line CSV line to parse
 * @return Vector of field strings
 */
std::vector<std::string> CSVReader::parseLine(const std::string& line) {
    std::vector<std::string> fields;
    std::string current_field;
    bool in_quotes = false;
    
    for (size_t i = 0; i < line.size(); ++i) {
        char c = line[i];
        
        if (c == '"') {
            in_quotes = !in_quotes;
        } else if (c == config_.delimiter && !in_quotes) {
            fields.push_back(current_field);
            current_field.clear();
        } else {
            current_field += c;
        }
    }
    
    fields.push_back(current_field);
    
    // Trim whitespace from each field
    for (auto& field : fields) {
        // Trim leading whitespace
        field.erase(0, field.find_first_not_of(" \t\r\n"));
        // Trim trailing whitespace
        field.erase(field.find_last_not_of(" \t\r\n") + 1);
    }
    
    return fields;
}

/**
 * @brief Parse a string to double
 *
 * @param str String representation of number
 * @return Parsed double value
 * @throws std::runtime_error if string cannot be parsed
 */
double CSVReader::parseValue(const std::string& str) {
    if (str.empty()) {
        throw std::runtime_error("CSVReader: Empty value cannot be parsed");
    }
    
    try {
        size_t idx;
        double value = std::stod(str, &idx);
        
        // Ensure entire string was consumed
        if (idx != str.size() &&
            str.find_first_not_of(" \t", idx) != std::string::npos) {
            throw std::runtime_error("Invalid number format");
        }
        
        return value;
    } catch (const std::exception& e) {
        throw std::runtime_error(
            "CSVReader: Cannot parse '" + str + "' as number");
    }
}

} // namespace ode_solver::utils